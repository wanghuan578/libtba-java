/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "service_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace essential { namespace service {

int _kMessageTypeValues[] = {
  MessageType::MT_SERVICE_STATE_SYNC,
  MessageType::MT_SERVICE_STATEY_RES
};
const char* _kMessageTypeNames[] = {
  "MT_SERVICE_STATE_SYNC",
  "MT_SERVICE_STATEY_RES"
};
const std::map<int, const char*> _MessageType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kMessageTypeValues, _kMessageTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


ApplicationInfo::~ApplicationInfo() throw() {
}


void ApplicationInfo::__set_pid(const int32_t val) {
  this->pid = val;
}

void ApplicationInfo::__set_ppid(const int32_t val) {
  this->ppid = val;
}

void ApplicationInfo::__set_upstream_flow_total(const int32_t val) {
  this->upstream_flow_total = val;
}

void ApplicationInfo::__set_upstream_flow_bytes(const int32_t val) {
  this->upstream_flow_bytes = val;
}

void ApplicationInfo::__set_downstream_flow_total(const int32_t val) {
  this->downstream_flow_total = val;
}

void ApplicationInfo::__set_downstream_flow_bytes(const int32_t val) {
  this->downstream_flow_bytes = val;
}

void ApplicationInfo::__set_current_connections(const int32_t val) {
  this->current_connections = val;
}

void ApplicationInfo::__set_max_connections(const int32_t val) {
  this->max_connections = val;
}

uint32_t ApplicationInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pid);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ppid);
          this->__isset.ppid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->upstream_flow_total);
          this->__isset.upstream_flow_total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->upstream_flow_bytes);
          this->__isset.upstream_flow_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->downstream_flow_total);
          this->__isset.downstream_flow_total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->downstream_flow_bytes);
          this->__isset.downstream_flow_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->current_connections);
          this->__isset.current_connections = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_connections);
          this->__isset.max_connections = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ApplicationInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ApplicationInfo");

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->pid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ppid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->ppid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("upstream_flow_total", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->upstream_flow_total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("upstream_flow_bytes", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->upstream_flow_bytes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("downstream_flow_total", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->downstream_flow_total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("downstream_flow_bytes", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->downstream_flow_bytes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("current_connections", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->current_connections);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_connections", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->max_connections);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ApplicationInfo &a, ApplicationInfo &b) {
  using ::std::swap;
  swap(a.pid, b.pid);
  swap(a.ppid, b.ppid);
  swap(a.upstream_flow_total, b.upstream_flow_total);
  swap(a.upstream_flow_bytes, b.upstream_flow_bytes);
  swap(a.downstream_flow_total, b.downstream_flow_total);
  swap(a.downstream_flow_bytes, b.downstream_flow_bytes);
  swap(a.current_connections, b.current_connections);
  swap(a.max_connections, b.max_connections);
  swap(a.__isset, b.__isset);
}

ApplicationInfo::ApplicationInfo(const ApplicationInfo& other0) {
  pid = other0.pid;
  ppid = other0.ppid;
  upstream_flow_total = other0.upstream_flow_total;
  upstream_flow_bytes = other0.upstream_flow_bytes;
  downstream_flow_total = other0.downstream_flow_total;
  downstream_flow_bytes = other0.downstream_flow_bytes;
  current_connections = other0.current_connections;
  max_connections = other0.max_connections;
  __isset = other0.__isset;
}
ApplicationInfo& ApplicationInfo::operator=(const ApplicationInfo& other1) {
  pid = other1.pid;
  ppid = other1.ppid;
  upstream_flow_total = other1.upstream_flow_total;
  upstream_flow_bytes = other1.upstream_flow_bytes;
  downstream_flow_total = other1.downstream_flow_total;
  downstream_flow_bytes = other1.downstream_flow_bytes;
  current_connections = other1.current_connections;
  max_connections = other1.max_connections;
  __isset = other1.__isset;
  return *this;
}
void ApplicationInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ApplicationInfo(";
  out << "pid=" << to_string(pid);
  out << ", " << "ppid=" << to_string(ppid);
  out << ", " << "upstream_flow_total=" << to_string(upstream_flow_total);
  out << ", " << "upstream_flow_bytes=" << to_string(upstream_flow_bytes);
  out << ", " << "downstream_flow_total=" << to_string(downstream_flow_total);
  out << ", " << "downstream_flow_bytes=" << to_string(downstream_flow_bytes);
  out << ", " << "current_connections=" << to_string(current_connections);
  out << ", " << "max_connections=" << to_string(max_connections);
  out << ")";
}


SystemInfo::~SystemInfo() throw() {
}


void SystemInfo::__set_task_num(const int32_t val) {
  this->task_num = val;
}

void SystemInfo::__set_cpu_num(const int16_t val) {
  this->cpu_num = val;
}

void SystemInfo::__set_cpu_percent(const double val) {
  this->cpu_percent = val;
}

void SystemInfo::__set_mem_total(const int32_t val) {
  this->mem_total = val;
}

void SystemInfo::__set_mem_used(const int32_t val) {
  this->mem_used = val;
}

void SystemInfo::__set_mem_avail(const int64_t val) {
  this->mem_avail = val;
}

void SystemInfo::__set_mem_percent(const double val) {
  this->mem_percent = val;
}

void SystemInfo::__set_swap_total(const int32_t val) {
  this->swap_total = val;
}

void SystemInfo::__set_swap_used(const int32_t val) {
  this->swap_used = val;
}

void SystemInfo::__set_swap_avail(const int32_t val) {
  this->swap_avail = val;
}

void SystemInfo::__set_swap_percent(const double val) {
  this->swap_percent = val;
}

void SystemInfo::__set_load_average(const double val) {
  this->load_average = val;
}

uint32_t SystemInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->task_num);
          this->__isset.task_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->cpu_num);
          this->__isset.cpu_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->cpu_percent);
          this->__isset.cpu_percent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mem_total);
          this->__isset.mem_total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mem_used);
          this->__isset.mem_used = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->mem_avail);
          this->__isset.mem_avail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->mem_percent);
          this->__isset.mem_percent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->swap_total);
          this->__isset.swap_total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->swap_used);
          this->__isset.swap_used = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->swap_avail);
          this->__isset.swap_avail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->swap_percent);
          this->__isset.swap_percent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->load_average);
          this->__isset.load_average = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SystemInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SystemInfo");

  xfer += oprot->writeFieldBegin("task_num", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->task_num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cpu_num", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->cpu_num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cpu_percent", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->cpu_percent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mem_total", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->mem_total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mem_used", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->mem_used);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mem_avail", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->mem_avail);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mem_percent", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->mem_percent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("swap_total", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->swap_total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("swap_used", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->swap_used);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("swap_avail", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->swap_avail);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("swap_percent", ::apache::thrift::protocol::T_DOUBLE, 11);
  xfer += oprot->writeDouble(this->swap_percent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("load_average", ::apache::thrift::protocol::T_DOUBLE, 12);
  xfer += oprot->writeDouble(this->load_average);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SystemInfo &a, SystemInfo &b) {
  using ::std::swap;
  swap(a.task_num, b.task_num);
  swap(a.cpu_num, b.cpu_num);
  swap(a.cpu_percent, b.cpu_percent);
  swap(a.mem_total, b.mem_total);
  swap(a.mem_used, b.mem_used);
  swap(a.mem_avail, b.mem_avail);
  swap(a.mem_percent, b.mem_percent);
  swap(a.swap_total, b.swap_total);
  swap(a.swap_used, b.swap_used);
  swap(a.swap_avail, b.swap_avail);
  swap(a.swap_percent, b.swap_percent);
  swap(a.load_average, b.load_average);
  swap(a.__isset, b.__isset);
}

SystemInfo::SystemInfo(const SystemInfo& other2) {
  task_num = other2.task_num;
  cpu_num = other2.cpu_num;
  cpu_percent = other2.cpu_percent;
  mem_total = other2.mem_total;
  mem_used = other2.mem_used;
  mem_avail = other2.mem_avail;
  mem_percent = other2.mem_percent;
  swap_total = other2.swap_total;
  swap_used = other2.swap_used;
  swap_avail = other2.swap_avail;
  swap_percent = other2.swap_percent;
  load_average = other2.load_average;
  __isset = other2.__isset;
}
SystemInfo& SystemInfo::operator=(const SystemInfo& other3) {
  task_num = other3.task_num;
  cpu_num = other3.cpu_num;
  cpu_percent = other3.cpu_percent;
  mem_total = other3.mem_total;
  mem_used = other3.mem_used;
  mem_avail = other3.mem_avail;
  mem_percent = other3.mem_percent;
  swap_total = other3.swap_total;
  swap_used = other3.swap_used;
  swap_avail = other3.swap_avail;
  swap_percent = other3.swap_percent;
  load_average = other3.load_average;
  __isset = other3.__isset;
  return *this;
}
void SystemInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SystemInfo(";
  out << "task_num=" << to_string(task_num);
  out << ", " << "cpu_num=" << to_string(cpu_num);
  out << ", " << "cpu_percent=" << to_string(cpu_percent);
  out << ", " << "mem_total=" << to_string(mem_total);
  out << ", " << "mem_used=" << to_string(mem_used);
  out << ", " << "mem_avail=" << to_string(mem_avail);
  out << ", " << "mem_percent=" << to_string(mem_percent);
  out << ", " << "swap_total=" << to_string(swap_total);
  out << ", " << "swap_used=" << to_string(swap_used);
  out << ", " << "swap_avail=" << to_string(swap_avail);
  out << ", " << "swap_percent=" << to_string(swap_percent);
  out << ", " << "load_average=" << to_string(load_average);
  out << ")";
}


ServiceInfo::~ServiceInfo() throw() {
}


void ServiceInfo::__set_app(const ApplicationInfo& val) {
  this->app = val;
}

void ServiceInfo::__set_system(const SystemInfo& val) {
  this->system = val;
}

void ServiceInfo::__set_route(const  ::essential::common::RouteInfo& val) {
  this->route = val;
}

uint32_t ServiceInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->app.read(iprot);
          this->__isset.app = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->system.read(iprot);
          this->__isset.system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->route.read(iprot);
          this->__isset.route = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ServiceInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ServiceInfo");

  xfer += oprot->writeFieldBegin("app", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->app.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("system", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->system.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("route", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->route.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ServiceInfo &a, ServiceInfo &b) {
  using ::std::swap;
  swap(a.app, b.app);
  swap(a.system, b.system);
  swap(a.route, b.route);
  swap(a.__isset, b.__isset);
}

ServiceInfo::ServiceInfo(const ServiceInfo& other4) {
  app = other4.app;
  system = other4.system;
  route = other4.route;
  __isset = other4.__isset;
}
ServiceInfo& ServiceInfo::operator=(const ServiceInfo& other5) {
  app = other5.app;
  system = other5.system;
  route = other5.route;
  __isset = other5.__isset;
  return *this;
}
void ServiceInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ServiceInfo(";
  out << "app=" << to_string(app);
  out << ", " << "system=" << to_string(system);
  out << ", " << "route=" << to_string(route);
  out << ")";
}

}} // namespace
